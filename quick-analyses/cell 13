import boto3, json, numpy as np, pandas as pd, re
from sklearn.metrics.pairwise import cosine_distances

# --------- CONFIG ----------
MODEL_ID = "amazon.titan-text-express-v1"   # keep same as before
REPRESENTATIVE_N = 8
MAX_SUBJECT_CHARS = 140
SUBJECT_COL = "Subject"
# ---------------------------

brt = boto3.client("bedrock-runtime", region_name=boto3.Session().region_name)

def truncate(s, n):
    s = "" if s is None else str(s).replace("\n", " ").strip()
    return (s[:n] + "…") if len(s) > n else s

def bedrock_invoke_titan(prompt: str) -> str:
    body = {
        "inputText": prompt,
        "textGenerationConfig": {
            "maxTokenCount": 300,
            "temperature": 0.0,   # reduce “creative” extra text
            "topP": 0.9
        }
    }
    resp = brt.invoke_model(
        modelId=MODEL_ID,
        body=json.dumps(body),
        accept="application/json",
        contentType="application/json",
    )
    out = json.loads(resp["body"].read())
    return out["results"][0]["outputText"]

def extract_first_json_object(s: str):
    """
    Extract the first top-level JSON object from a string.
    Handles cases where the model adds extra text before/after JSON.
    """
    if not s:
        raise ValueError("Empty model output")

    start = s.find("{")
    if start == -1:
        raise ValueError("No '{' found in output")

    depth = 0
    in_str = False
    escape = False

    for i in range(start, len(s)):
        ch = s[i]
        if in_str:
            if escape:
                escape = False
            elif ch == "\\":
                escape = True
            elif ch == '"':
                in_str = False
        else:
            if ch == '"':
                in_str = True
            elif ch == "{":
                depth += 1
            elif ch == "}":
                depth -= 1
                if depth == 0:
                    candidate = s[start:i+1]
                    return json.loads(candidate)

    raise ValueError("Unbalanced JSON braces in output")

labels = []
centers = kmeans_emb.cluster_centers_

for theme_id in range(NUM_THEMES_EMB):
    mask = work_emb["theme_cluster_emb"] == theme_id
    if mask.sum() == 0:
        continue

    theme_vectors = embeddings[mask]
    theme_rows = work_emb.loc[mask].copy()

    dists = cosine_distances(theme_vectors, centers[theme_id].reshape(1, -1)).flatten()
    top_idx = np.argsort(dists)[:REPRESENTATIVE_N]
    reps = theme_rows.iloc[top_idx]

    examples = [f"- {truncate(x, MAX_SUBJECT_CHARS)}" for x in reps[SUBJECT_COL].fillna("").astype(str).tolist()]

    prompt = f"""
Return ONLY a single JSON object (no extra text). Do not include code fences.

Task: Label this support-ticket theme cluster based on the representative ticket subjects.

JSON schema:
{{
  "label": "3-6 words, Title Case",
  "description": "1 sentence plain English",
  "keywords": ["3-6 short keywords/phrases"],
  "confidence": "low|medium|high"
}}

Representative ticket subjects:
{chr(10).join(examples)}
""".strip()

    raw = None
    parsed = None
    err = None

    try:
        raw = bedrock_invoke_titan(prompt).strip()
        parsed = extract_first_json_object(raw)
    except Exception as e:
        err = str(e)
        parsed = {"label":"(parse_failed)", "description":err, "keywords":[], "confidence":"low"}

    labels.append({
        "theme_cluster_emb": theme_id,
        "tickets": int(mask.sum()),
        "label": parsed.get("label"),
        "confidence": parsed.get("confidence"),
        "keywords": ", ".join(parsed.get("keywords", [])) if isinstance(parsed.get("keywords", []), list) else str(parsed.get("keywords")),
        "description": parsed.get("description"),
        "raw_output_preview": (raw[:250] + "…") if isinstance(raw, str) and len(raw) > 250 else raw
    })

label_df = pd.DataFrame(labels).sort_values("tickets", ascending=False)
display(label_df)
